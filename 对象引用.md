# Python学习笔记 —— 对象引用 

### 动态类型与静态类型

关于一个表达式的对象（变量）的静态类型和动态类型需要从两点进行分析：

（1）该对象（变量）的静态类型和动态类型是否相等；

> 一个对象（变量）的静态类型就是其声明类型，如表达式int a 中的int 就是对象a 的声明类型，即静态类型；
> 一个对象（变量）的动态类型是指程序执行过程中对象（指针或引用）实际所指对象的类型。

（2）如果该对象的静态类型和动态类型不相等，其动态类型是否有作用。

> 那到底什么时候一个对象（变量）的动态类型能发挥其威力呢？三个条件：
> ①该对象是指针或引用形式；
> ②该对象的静态与动态类型不同；
> ③应用场景为带虚函数的继承体系结构。

### 变量-对象-引用

```python 
a = 3
```

> 在运行`a=3`后，变量`a`变成了对象`3`的一个引用。在内部，变量事实上是到对象内存空间的一个指针

![变量-对象-引用](http://img.blog.csdn.net/20141210215031875)

```python
x = 42      #变量绑定到整型对象
x = 'Hello' #现在又成了字符串
x = [1,2,3] #现在又成了列表
```

> 因为Python的变量不过是对象的引用，或指向对象的指针，因此在程序中可以经常改变变量引用

专业表述如下:

- 变量是一个系统表的元素，拥有指向对象的连接的空间

- 对象是被分配的一块内存，存储其所代表的值

- 引用是自动形成的从变量到对象的指针

**特别注意: 类型属于对象，不是变量** 

比如像刚才的`a=3`, 整数对象`3`包含了两重信息：

1. 值为3

2. 一个头部信息：告诉Pthyon，这是个整数对象 [相当于一个指向int的指针]

### 可变对象-不可变对象

数据类型和不可变数据类型的区别是 **内存存储空间中的值可不可被修改** 

不可变数据类型：一旦创建就不可修改的对象，包括数字，字符串，元祖

```python
a = 10 #在内存中开辟一个存储空间，将a指向该空间
a = b #将b指向a的内存存储空间
a = 15 #将a指向新的存储空间，并未改变原空间中的值

s = 'hello'
s[0] = 'H'#将s字符串中的第一个字符h改为H
'''
报错：（s为str数据类型，为不可变对象，所以对s进行更改操作会报错）
TypeError: 'str' object does not support item assignment
'''
```

可变数据类型：可以修改的对象，包括：列表、字典

```python
a = ['adfdaf','dfadfd',32313] #在内存中开辟一个存储空间，将[]中的内容全部存入该存储空间中，该存储空间中的值即可被改变
```

### a+=a 不等于 a=a+a

```python
a = 100

def sum(num):
    num += num
    print(num)

sum(a)
print(a)
'''
输出结果：
200
100
'''
a = [100]

def sum(num):
    num += num
    print(num)

sum(a)
print(a)
'''
输出结果：
[100, 100]
[100, 100]
'''
```

在调用函数时，`num`指向`a`对象，当`num`执行`num += num`语句时，直接对`num`对象进行操作，若是`num`是不可变数据类型，则新建一个名为`num`的局部变量执行操作，如`a = 100`，若`num`为可变数据类型，则直接对`num`对象执行操作，如`a = [100]`。

```python
a = [100]

def sum(num):
    num = num + num
    print(num)

sum(a)
print(a)
'''
输出结果：
[100, 100]
[100]
'''
```
在执行`num = num + num`语句时，先执行等号右边的`num + num`，执行完等号右边语句后，由于未声明`num`为全局变量，所以对`num`在局部函数中的操作影响不到全局变量`num`。

**两种操作的区别在于 += 是直接对 num 对象本身的操作，而 =   + 是一种对变量引用赋值的操作。** 

### 深拷贝-浅拷贝

**1、利用切片技术进行拷贝，应用于所有的序列，包括：列表、字符串、元祖，字典除外** 

```python
b = a[:]#仅顶层对象拷贝 浅拷贝
```

**2、深浅拷贝，即可用于序列，也可用于字典**

```python
import copy

b = copy.copy(a)#仅顶层对象拷贝 浅拷贝
c = copy.deepcopy(a)#所有层对象拷贝，顶层对象及其嵌套对象 深拷贝
```

- 深浅拷贝都是对源对象的复制，占用不同的内存空间

- 如果源对象只有一级目录的话，源做任何改动，不影响深浅拷贝对象

- 如果源对象不止一级目录的话，源做任何改动，都要影响浅拷贝，但不影响深拷贝

- 序列对象的切片其实是浅拷贝，即只拷贝顶级的对象

